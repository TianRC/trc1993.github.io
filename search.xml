<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[C++文件和流]]></title>
    <url>%2FC-Stream%2F</url>
    <content type="text"><![CDATA[前言 到目前为止，我们已经使用了 iostream 标准库，它提供了 cin 和 cout 方法分别用于从标准输入读取流和向标准输出写入流。 介绍如何从文件读取流和向文件写入流。这就需要用到 C++ 中另一个标准库 fstream，它定义了三个新的数据类型： 数据类型 描述 ofstream 输出文件流，创建文件并向文件写入信息。 ifstream 输入文件流，从文件读取信息。 fstream 文件流，且同时具有 ofstream 和 ifstream 两种功能。 要在 C++ 中进行文件处理，必须在 C++ 源代码文件中包含头文件 和 。 打开文件 在从文件读取信息或者向文件写入信息之前，必须先打开文件。ofstream 和 fstream 对象都可以用来打开文件进行写操作，如果只需要打开文件进行读操作，则使用 ifstream 对象。 下面是 open() 函数的标准语法，open() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。 1void open(const char *filename, ios::openmode mode); 在这里，open() 成员函数的第一参数指定要打开的文件的名称和位置，第二个参数定义文件被打开的模式。 模式标志 描述 ios::app 追加模式。所有写入都追加到文件末尾。 ios::ate 文件打开后定位到文件末尾。 ios::in 打开文件用于读取。 ios::out 打开文件用于写入。 ios::trunc 如果该文件已经存在，其内容将在打开文件之前被截断，即把文件长度设为 0。 您可以把以上两种或两种以上的模式结合使用。例如，如果您想要以写入模式打开文件，并希望截断文件，以防文件已存在，那么您可以使用下面的语法： 12ofstream outfile;outfile.open("file.dat", ios::out | ios::trunc ); 类似地，您如果想要打开一个文件用于读写，可以使用下面的语法： 12fstream afile;afile.open("file.dat", ios::out | ios::in ); 关闭文件当 C++ 程序终止时，它会自动关闭刷新所有流，释放所有分配的内存，并关闭所有打开的文件。但程序员应该养成一个好习惯，在程序终止前关闭所有打开的文件。 下面是 close() 函数的标准语法，close() 函数是 fstream、ifstream 和 ofstream 对象的一个成员。1void close(); 写入文件 在 C++ 编程中，我们使用流插入运算符（ &lt;&lt; ）向文件写入信息，就像使用该运算符输出信息到屏幕上一样。唯一不同的是，在这里您使用的是 ofstream 或 fstream 对象，而不是 cout 对象。 读取文件 在 C++ 编程中，我们使用流提取运算符（ &gt;&gt; ）从文件读取信息，就像使用该运算符从键盘输入信息一样。唯一不同的是，在这里您使用的是 ifstream 或 fstream 对象，而不是 cin 对象。 读取 &amp; 写入实例 下面的 C++ 程序以读写模式打开一个文件。在向文件 afile.dat 写入用户输入的信息之后，程序从文件读取信息，并将其输出到屏幕上： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// demo.cpp: 定义应用程序的入口点。//#include "demo.h"#include &lt;fstream&gt;#include &lt;iostream&gt;using namespace std;int main()&#123; char data[100]; // 以写模式打开文件 ofstream outfile; outfile.open("afile.dat"); cout &lt;&lt; "Writing to the file" &lt;&lt; endl; cout &lt;&lt; "Enter your name: "; cin.getline(data, 100); // 向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; cout &lt;&lt; "Enter your age: "; cin &gt;&gt; data; cin.ignore(); // 再次向文件写入用户输入的数据 outfile &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 outfile.close(); // 以读模式打开文件 ifstream infile; infile.open("afile.dat"); cout &lt;&lt; "Reading from the file" &lt;&lt; endl; infile &gt;&gt; data; // 在屏幕上写入数据 cout &lt;&lt; data &lt;&lt; endl; // 再次从文件读取数据，并显示它 infile &gt;&gt; data; cout &lt;&lt; data &lt;&lt; endl; // 关闭打开的文件 infile.close(); system("pause"); return 0;&#125; Result 1234567Writing to the fileEnter your name: TRCEnter your age: 25Reading from the fileTRC25请按任意键继续. . . 上面的实例中使用了 cin 对象的附加函数，比如 getline()函数从外部读取一行，ignore() 函数会忽略掉之前读语句留下的多余字符。 文件位置指针istream 和 ostream 都提供了用于重新定位文件位置指针的成员函数。这些成员函数包括关于 istream 的 seekg（”seek get“）和关于 ostream 的 seekp（”seek put“）。 seekg 和 seekp 的参数通常是一个长整型。第二个参数可以用于指定查找方向。查找方向可以是 ios::beg（默认的，从流的开头开始定位），也可以是 ios::cur（从流的当前位置开始定位），也可以是 ios::end（从流的末尾开始定位）。 文件位置指针是一个整数值，指定了从文件的起始位置到指针所在位置的字节数。下面是关于定位 “get“ 文件位置指针的实例： 1234567891011// 定位到 fileObject 的第 n 个字节（假设是 ios::beg）fileObject.seekg( n ); // 把文件的读指针从 fileObject 当前位置向后移 n 个字节fileObject.seekg( n, ios::cur ); // 把文件的读指针从 fileObject 末尾往回移 n 个字节fileObject.seekg( n, ios::end ); // 定位到 fileObject 的末尾fileObject.seekg( 0, ios::end );]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++预处理器]]></title>
    <url>%2FC-Preprocessor%2F</url>
    <content type="text"><![CDATA[前言 预处理器是一些指令，指示编译器在实际编译之前所需完成的预处理。所有的预处理器指令都是以井号（#）开头，只有空格字符可以出现在预处理指令之前。预处理指令不是 C++ 语句，所以它们不会以分号（;）结尾。我们已经看到，之前所有的实例中都有 #include 指令。这个宏用于把头文件包含到源文件中。C++ 还支持很多预处理指令，比如 #include、#define、#if、#else、#line 等，让我们一起看看这些重要指令。 define 预处理 #define 预处理指令用于创建符号常量。该符号常量通常称为宏，指令的一般形式是： 1#define macro-name replacement-text 当这一行代码出现在一个文件中时，在该文件中后续出现的所有宏都将会在程序编译之前被替换为 replacement-text。例如： 123456789101112#include &lt;iostream&gt;using namespace std; #define PI 3.14159 int main ()&#123; cout &lt;&lt; "Value of PI :" &lt;&lt; PI &lt;&lt; endl; return 0;&#125; 现在，让我们测试这段代码，看看预处理的结果。假设源代码文件已经存在，接下来使用 -E 选项进行编译，并把结果重定向到 test.p。现在，如果您查看 test.p 文件，将会看到它已经包含大量的信息，而且在文件底部的值被改为如下：12345678910$ gcc -E test.cpp &gt; test.p...int main ()&#123; cout &lt;&lt; "Value of PI :" &lt;&lt; 3.14159 &lt;&lt; endl; return 0;&#125; 参数宏 您可以使用 #define 来定义一个带有参数的宏，如下所示： 1234567891011121314#include &lt;iostream&gt;using namespace std; #define MIN(a,b) (a&lt;b ? a : b) int main ()&#123; int i, j; i = 100; j = 30; cout &lt;&lt;"较小的值为：" &lt;&lt; MIN(i, j) &lt;&lt; endl; return 0;&#125; Result 1较小的值为：30 条件编译 有几个指令可以用来有选择地对部分程序源代码进行编译。这个过程被称为条件编译。 条件预处理器的结构与 if 选择结构很像。请看下面这段预处理器的代码：123#ifndef NULL #define NULL 0#endif 您可以只在调试时进行编译，调试开关可以使用一个宏来实现，如下所示： 123#ifdef DEBUG cerr &lt;&lt;"Variable x = " &lt;&lt; x &lt;&lt; endl;#endif 如果在指令 #ifdef DEBUG 之前已经定义了符号常量 DEBUG，则会对程序中的 cerr 语句进行编译。您可以使用 #if 0 语句注释掉程序的一部分，如下所示： 123#if 0 不进行编译的代码#endif 让我们尝试下面的实例： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;#define DEBUG #define MIN(a,b) (((a)&lt;(b)) ? a : b) int main ()&#123; int i, j; i = 100; j = 30;#ifdef DEBUG cerr &lt;&lt;"Trace: Inside main function" &lt;&lt; endl;#endif #if 0 /* 这是注释部分 */ cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl;#endif cout &lt;&lt;"The minimum is " &lt;&lt; MIN(i, j) &lt;&lt; endl; #ifdef DEBUG cerr &lt;&lt;"Trace: Coming out of main function" &lt;&lt; endl;#endif return 0;&#125; Result 123Trace: Inside main functionThe minimum is 30Trace: Coming out of main function # 和 ## 运算符 # 和 ## 预处理运算符在 C++ 和 ANSI/ISO C 中都是可用的。# 运算符会把 replacement-text 令牌转换为用引号引起来的字符串。 请看下面的宏定义： 12345678910111213#include "demo.h"#define MKSTR( x ) #xusing namespace std;int main()&#123; cout &lt;&lt; "Hello CMake。" &lt;&lt; endl; cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl; system("pause"); return 0;&#125; Result 123Hello CMake。HELLO C++请按任意键继续. . . 让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行：1cout &lt;&lt; MKSTR(HELLO C++) &lt;&lt; endl; 转换成了： 1cout &lt;&lt; "HELLO C++" &lt;&lt; endl; ## 运算符用于连接两个令牌。下面是一个实例：1#define CONCAT( x, y ) x ## y 当 CONCAT 出现在程序中时，它的参数会被连接起来，并用来取代宏。例如，程序中 CONCAT(HELLO, C++) 会被替换为 “HELLO C++”，如下面实例所示。 1234567891011#include &lt;iostream&gt;using namespace std; #define concat(a, b) a ## bint main()&#123; int xy = 100; cout &lt;&lt; concat(x, y); return 0;&#125; Result 1100 让我们来看看它是如何工作的。不难理解，C++ 预处理器把下面这行： 1cout &lt;&lt; concat(x, y); 转换成了：1cout &lt;&lt; xy; C++ 中的预定义宏 C++ 提供了下表所示的一些预定义宏： 宏 描述 LINE 这会在程序编译时包含当前行号。 FILE 这会在程序编译时包含当前文件名。 DATE 这会包含一个形式为 month/day/year 的字符串，它表示把源文件转换为目标代码的日期。 TIME 这会包含一个形式为 hour:minute:second 的字符串，它表示程序被编译的时间。 让我们看看上述这些宏的实例： 123456789101112131415161718// demo.cpp: 定义应用程序的入口点。//#include "demo.h"#define concat(a, b,c) a ## b ## cusing namespace std;int main()&#123; cout &lt;&lt; "Value of __LINE__ : " &lt;&lt; __LINE__ &lt;&lt; endl; cout &lt;&lt; "Value of __FILE__ : " &lt;&lt; __FILE__ &lt;&lt; endl; cout &lt;&lt; "Value of __DATE__ : " &lt;&lt; __DATE__ &lt;&lt; endl; cout &lt;&lt; "Value of __TIME__ : " &lt;&lt; __TIME__ &lt;&lt; endl; system("pause"); return 0;&#125; Result 12345Value of __LINE__ : 12Value of __FILE__ : C:\Users\wb-trc409737\source\repos\demo\demo\demo.cppValue of __DATE__ : Aug 21 2018Value of __TIME__ : 11:18:26请按任意键继续. . .]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 模板]]></title>
    <url>%2FC-template%2F</url>
    <content type="text"><![CDATA[前言 模板是泛型编程的基础，泛型编程即以一种独立于任何特定类型的方式编写代码。模板是创建泛型类或函数的蓝图或公式。库容器，比如迭代器和算法，都是泛型编程的例子，它们都使用了模板的概念。每个容器都有一个单一的定义，比如 向量，我们可以定义许多不同类型的向量，比如 vector 或 vector 。您可以使用模板来定义函数和类，接下来让我们一起来看看如何使用。 函数模板模板函数定义的一般形式如下所示： 1234template &lt;class type&gt; ret-type func-name(parameter list)&#123; // 函数的主体&#125; 在这里，type 是函数所使用的数据类型的占位符名称。这个名称可以在函数定义中使用。 下面是函数模板的实例，返回两个数中的最大值： 123456789101112131415161718192021222324252627#include &lt;iostream&gt;#include &lt;string&gt; using namespace std; template &lt;typename T&gt;inline T const&amp; Max (T const&amp; a, T const&amp; b) &#123; return a &lt; b ? b:a; &#125; int main ()&#123; int i = 39; int j = 20; cout &lt;&lt; "Max(i, j): " &lt;&lt; Max(i, j) &lt;&lt; endl; double f1 = 13.5; double f2 = 20.7; cout &lt;&lt; "Max(f1, f2): " &lt;&lt; Max(f1, f2) &lt;&lt; endl; string s1 = "Hello"; string s2 = "World"; cout &lt;&lt; "Max(s1, s2): " &lt;&lt; Max(s1, s2) &lt;&lt; endl; return 0;&#125; Result 123Max(i, j): 39Max(f1, f2): 20.7Max(s1, s2): World 类模板 正如我们定义函数模板一样，我们也可以定义类模板。泛型类声明的一般形式如下所示： 12345template &lt;class type&gt; class class-name &#123;...&#125; 在这里，type 是占位符类型名称，可以在类被实例化的时候进行指定。您可以使用一个逗号分隔的列表来定义多个泛型数据类型。 下面的实例定义了类 Stack&lt;&gt;，并实现了泛型方法来对元素进行入栈出栈操作： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;cstdlib&gt;#include &lt;string&gt;#include &lt;stdexcept&gt; using namespace std; template &lt;class T&gt;class Stack &#123; private: vector&lt;T&gt; elems; // 元素 public: void push(T const&amp;); // 入栈 void pop(); // 出栈 T top() const; // 返回栈顶元素 bool empty() const&#123; // 如果为空则返回真。 return elems.empty(); &#125; &#125;; template &lt;class T&gt;void Stack&lt;T&gt;::push (T const&amp; elem) &#123; // 追加传入元素的副本 elems.push_back(elem); &#125; template &lt;class T&gt;void Stack&lt;T&gt;::pop () &#123; if (elems.empty()) &#123; throw out_of_range("Stack&lt;&gt;::pop(): empty stack"); &#125; // 删除最后一个元素 elems.pop_back(); &#125; template &lt;class T&gt;T Stack&lt;T&gt;::top () const &#123; if (elems.empty()) &#123; throw out_of_range("Stack&lt;&gt;::top(): empty stack"); &#125; // 返回最后一个元素的副本 return elems.back(); &#125; int main() &#123; try &#123; Stack&lt;int&gt; intStack; // int 类型的栈 Stack&lt;string&gt; stringStack; // string 类型的栈 // 操作 int 类型的栈 intStack.push(7); cout &lt;&lt; intStack.top() &lt;&lt;endl; // 操作 string 类型的栈 stringStack.push("hello"); cout &lt;&lt; stringStack.top() &lt;&lt; std::endl; stringStack.pop(); stringStack.pop(); &#125; catch (exception const&amp; ex) &#123; cerr &lt;&lt; "Exception: " &lt;&lt; ex.what() &lt;&lt;endl; return -1; &#125; &#125; Result 1237helloException: Stack&lt;&gt;::pop(): empty stack]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Path(PathMeasure)]]></title>
    <url>%2FPathMeasure%2F</url>
    <content type="text"><![CDATA[前言在Path在UI体系当中不论是在自定义View还是动画，都占有举足轻重的地位。绘制Path，可以通过Android提供的API，或者是贝塞尔曲线、数学函数、图形组合等等方式，而要获取Path上每一个构成点的坐标，一般需要知道Path的函数方法，例如求解贝塞尔曲线上的点的De Casteljau算法，但对于一般的Path来说，是很难通过简单的函数方法来进行计算的，那么，今天需要了解的就是PathMeasure，关于Path测量的运用 PathMeasure今天需要了解的API非常简单，关于Path的测量，我们首先来看一些效果 这种load效果我们经常在项目当中遇见，那么其中有一部分效果是通过测量Path来进行实现的 那么首先我们来看到PathMeasure这个类，那么具体API详细介绍我就列入到下面，今天最主要的核心是，掌握这个类的使用技巧，而不是死板的API，那么我们来首先先看下这个类当中的API 公共方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185public class PathMeasure &#123;private Path mPath;/** * Create an empty PathMeasure object. To uses this to measure the length * of a path, and/or to find the position and tangent along it, call * setPath. * 创建一个空的PathMeasure *用这个构造函数可创建一个空的 PathMeasure， * 但是使用之前需要先调用 setPath 方法来与 Path 进行关联。 * 被关联的 Path 必须是已经创建好的， * 如果关联之后 Path 内容进行了更改， * 则需要使用 setPath 方法重新关联。 * Note that once a path is associated with the measure object, it is * undefined if the path is subsequently modified and the the measure object * is used. If the path is modified, you must call setPath with the path. */public PathMeasure() &#123; mPath = null; native_instance = native_create(0, false);&#125;/** * Create a PathMeasure object associated with the specified path object * (already created and specified). The measure object can now return the * path's length, and the position and tangent of any position along the * path. * * Note that once a path is associated with the measure object, it is * undefined if the path is subsequently modified and the the measure object * is used. If the path is modified, you must call setPath with the path. * 创建 PathMeasure 并关联一个指定的Path(Path需要已经创建完成)。 * 用这个构造函数是创建一个 PathMeasure 并关联一个 Path， * 其实和创建一个空的 PathMeasure 后调用 setPath 进行关联效果是一样的， * 同样，被关联的 Path 也必须是已经创建好的，如果关联之后 Path 内容进行了更改， * 则需要使用 setPath 方法重新关联。 *该方法有两个参数，第一个参数自然就是被关联的 Path 了， * 第二个参数是用来确保 Path 闭合，如果设置为 true， * 则不论之前Path是否闭合，都会自动闭合该 Path(如果Path可以闭合的话)。 * 在这里有两点需要明确: * 1.不论 forceClosed 设置为何种状态(true 或者 false)， * 都不会影响原有Path的状态，即 Path 与 PathMeasure 关联之后，之前的的 Path 不会有任何改变。 * 2.forceClosed 的设置状态可能会影响测量结果， * 如果 Path 未闭合但在与 PathMeasure 关联的时候设置 forceClosed 为 true 时， * 测量结果可能会比 Path 实际长度稍长一点，获取到到是该 Path 闭合时的状态。 * @param path The path that will be measured by this object 被关联的Path * @param forceClosed If true, then the path will be considered as "closed" * even if its contour was not explicitly closed. */public PathMeasure(Path path, boolean forceClosed) &#123; // The native implementation does not copy the path, prevent it from being GC'd mPath = path; native_instance = native_create(path != null ? path.readOnlyNI() : 0, forceClosed);&#125;/** * Assign a new path, or null to have none. * 关联一个Path */public void setPath(Path path, boolean forceClosed) &#123; mPath = path; native_setPath(native_instance, path != null ? path.readOnlyNI() : 0, forceClosed);&#125;/** * Return the total length of the current contour, or 0 if no path is * associated with this measure object. * 返回当前轮廓的总长度，或者如果没有路径，则返回0。与此度量对象相关联。 */public float getLength() &#123; return native_getLength(native_instance);&#125;/** * Pins distance to 0 &lt;= distance &lt;= getLength(), and then computes the * corresponding position and tangent. Returns false if there is no path, * or a zero-length path was specified, in which case position and tangent * are unchanged. * 获取指定长度的位置坐标及该点切线值 * @param distance The distance along the current contour to sample 位置 * @param pos If not null, returns the sampled position (x==[0], y==[1]) 坐标值 * @param tan If not null, returns the sampled tangent (x==[0], y==[1]) 切线值 * @return false if there was no path associated with this measure object*/public boolean getPosTan(float distance, float pos[], float tan[]) &#123; if (pos != null &amp;&amp; pos.length &lt; 2 || tan != null &amp;&amp; tan.length &lt; 2) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; return native_getPosTan(native_instance, distance, pos, tan);&#125;public static final int POSITION_MATRIX_FLAG = 0x01; // must match flags in SkPathMeasure.hpublic static final int TANGENT_MATRIX_FLAG = 0x02; // must match flags in SkPathMeasure.h/** * Pins distance to 0 &lt;= distance &lt;= getLength(), and then computes the * corresponding matrix. Returns false if there is no path, or a zero-length * path was specified, in which case matrix is unchanged. * * @param distance The distance along the associated path * @param matrix Allocated by the caller, this is set to the transformation * associated with the position and tangent at the specified distance * @param flags Specified what aspects should be returned in the matrix. */public boolean getMatrix(float distance, Matrix matrix, int flags) &#123; return native_getMatrix(native_instance, distance, matrix.native_instance, flags);&#125;/** * Given a start and stop distance, return in dst the intervening * segment(s). If the segment is zero-length, return false, else return * true. startD and stopD are pinned to legal values (0..getLength()). * If startD &gt;= stopD then return false (and leave dst untouched). * Begin the segment with a moveTo if startWithMoveTo is true. * * &lt;p&gt;On &#123;@link android.os.Build.VERSION_CODES#KITKAT&#125; and earlier * releases, the resulting path may not display on a hardware-accelerated * Canvas. A simple workaround is to add a single operation to this path, * such as &lt;code&gt;dst.rLineTo(0, 0)&lt;/code&gt;.&lt;/p&gt; * 给定启动和停止距离， * 在DST中返回中间段。 * 如果该段为零长度，则返回false， * 否则返回true。 * StestD和Stutd被固定到合法值（0…GigLangTh（））。 * startD&gt;＝stopD，则返回false（并保持DST未被触碰）。 * 如果有一个假设是正确的，就开始以一个模式开始。 * * 早期版本，结果路径可能不会在硬件加速中显示。 * Canvas。 * 一个简单的解决方法是在这个路径中添加一个操作， * 这样的SDST. RLIN to（0, 0） */public boolean getSegment(float startD, float stopD, Path dst, boolean startWithMoveTo) &#123; // Skia used to enforce this as part of it's API, but has since relaxed that restriction // so to maintain consistency in our API we enforce the preconditions here. float length = getLength(); if (startD &lt; 0) &#123; startD = 0; &#125; if (stopD &gt; length) &#123; stopD = length; &#125; if (startD &gt;= stopD) &#123; return false; &#125; return native_getSegment(native_instance, startD, stopD, dst.mutateNI(), startWithMoveTo);&#125;/** * Return true if the current contour is closed() * 是否闭合 */public boolean isClosed() &#123; return native_isClosed(native_instance);&#125;/** * Move to the next contour in the path. Return true if one exists, or * false if we're done with the path. */public boolean nextContour() &#123; return native_nextContour(native_instance);&#125;protected void finalize() throws Throwable &#123; native_destroy(native_instance); native_instance = 0; // Other finalizers can still call us.&#125;private static native long native_create(long native_path, boolean forceClosed);private static native void native_setPath(long native_instance, long native_path, boolean forceClosed);private static native float native_getLength(long native_instance);private static native boolean native_getPosTan(long native_instance, float distance, float pos[], float tan[]);private static native boolean native_getMatrix(long native_instance, float distance, long native_matrix, int flags);private static native boolean native_getSegment(long native_instance, float startD, float stopD, long native_path, boolean startWithMoveTo);private static native boolean native_isClosed(long native_instance);private static native boolean native_nextContour(long native_instance);private static native void native_destroy(long native_instance);/* package */private long native_instance; 从源码上分析我们可以看得到其实这个类就是为了让我们测量到当前Path所在的位置API不多，那么到底怎么运用呢？首先我们来分析这个效果 很明显我们看到当前这里是一个圆，运用了一张图片，让这张图能够沿着当前的这个圆进行移动那么，这个圆形是我们用Path所绘制的，那么当前Path会记录下当前圆的所有点，而我们需要将那个箭头图片绘制到我们path的点上面，并且按照圆形角度来进行操控而图形是这样的那么这个时候我们能够反映过来，去得到当前图片进行旋转，能够做到这一点， 但是我们如何判断这旋转的角度？ 而测量当中提供了 12345678910111213141516171819/** * Pins distance to 0 &lt;= distance &lt;= getLength(), and then computes the * corresponding position and tangent. Returns false if there is no path, * or a zero-length path was specified, in which case position and tangent * are unchanged. * 获取指定长度的位置坐标及该点切线值 * @param distance The distance along the current contour to sample PATH起点的长度取值范围: 0 &lt;= distance &lt;= getLength * @param pos If not null, returns the sampled position (x==[0], y==[1]) 坐标值 * @param tan If not null, returns the sampled tangent (x==[0], y==[1]) 切线值 * @return false if there was no path associated with this measure object*/public boolean getPosTan(float distance, float pos[], float tan[]) &#123; if (pos != null &amp;&amp; pos.length &lt; 2 || tan != null &amp;&amp; tan.length &lt; 2) &#123; throw new ArrayIndexOutOfBoundsException(); &#125; return native_getPosTan(native_instance, distance, pos, tan);&#125; 那么此时看到这个getPosTan方法其实我们就能够很明显了解到，通过这个方法我们可以根据path的长度值，去取得指定长度所在的XY和切线XY，见下图那么此时能够看到所谓的切线,下面扫盲，段位高跳过几何上，切线指的是一条刚好触碰到曲线上某一点的直线。更准确地说，当切线经过曲线上的某点（即切点）时，切线的方向与曲线上该点的方向是相同的。平面几何中，将和圆只有一个公共交点的直线叫做圆的切线正切函数是直角三角形中，对边与邻边的比值叫做正切。放在直角坐标系中（如图）即 tanθ=y/x而tan就是我们的正切值如上图，参考上图随机选取了一个橙点（具体位置），那么切线是和橙点相交的这条线，切线角度为垂直关系，所以如下图实在不理解TAN的话，你们就理解为当前得到了圆心坐标，因为圆的切线是圆心《建议去复习下初中数学》那么此时，我们拿到的getPosTan方法，能够把当前这个点，和这个点的正切值拿到，我们可以通过反正切计算取得角度,那么橙线和X轴的夹角其实实际上应该是我们到时候显示过去的角度，那么此时，看下图 红线所绘制的角度是我们当前角度，绿线绘制的是需要旋转的角度， 那么我们现在手里拥有的资源是，当前正切值，通过正切值我们运用公式可以计算得到当前角度Math.tan2(tan[1], tan[0]) * 180 / PI 而反切角度的话是Math.atan2(tan[1], tan[0]) * 180 / PI这个就是我们的要移动的角度 那么我们当前上面这个案例就能完成 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091public class MyView1 extends View &#123;private float currentValue = 0; // 用于纪录当前的位置,取值范围[0,1]映射Path的整个长度private float[] pos; // 当前点的实际位置private float[] tan; // 当前点的tangent值,用于计算图片所需旋转的角度private Bitmap mBitmap; // 箭头图片private Matrix mMatrix; // 矩阵,用于对图片进行一些操作private Paint mDeafultPaint;private int mViewWidth;private int mViewHeight;private Paint mPaint;public MyView1(Context context) &#123; super(context); init(context);&#125;private void init(Context context) &#123; pos = new float[2]; tan = new float[2]; BitmapFactory.Options options = new BitmapFactory.Options(); options.inSampleSize = 8; // 缩放图片 mBitmap = BitmapFactory.decodeResource(context.getResources(), R.drawable.arrow, options); mMatrix = new Matrix(); mDeafultPaint = new Paint(); mDeafultPaint.setColor(Color.RED); mDeafultPaint.setStrokeWidth(5); mDeafultPaint.setStyle(Paint.Style.STROKE); mPaint = new Paint(); mPaint.setColor(Color.DKGRAY); mPaint.setStrokeWidth(2); mPaint.setStyle(Paint.Style.STROKE);&#125;@Overrideprotected void onSizeChanged(int w, int h, int oldw, int oldh) &#123; super.onSizeChanged(w, h, oldw, oldh); mViewWidth = w; mViewHeight = h;&#125;@Overrideprotected void onDraw(Canvas canvas) &#123; super.onDraw(canvas); canvas.drawColor(Color.WHITE); // 平移坐标系 canvas.translate(mViewWidth/2,mViewHeight/2); // 画坐标线 canvas.drawLine(-canvas.getWidth(),0,canvas.getWidth(),0,mPaint); canvas.drawLine(0,-canvas.getHeight(),0,canvas.getHeight(),mPaint); Path path = new Path(); // 创建 Path path.addCircle(0, 0, 200, Path.Direction.CW); // 添加一个圆形 Log.i("barry","----------------------pos[0] = " + pos[0] + "pos[1] = " +pos[1]); Log.i("barry","----------------------tan[0] = " + tan[0] + "tan[1] = " +tan[1]); PathMeasure measure = new PathMeasure(path, false); // 创建 PathMeasure currentValue += 0.005; // 计算当前的位置在总长度上的比例[0,1] if (currentValue &gt;= 1) &#123; currentValue = 0; &#125; // 方案一 // 获取当前位置的坐标以及趋势 measure.getPosTan(measure.getLength() * currentValue, pos, tan); canvas.drawCircle(tan[0],tan[1],20,mDeafultPaint); // 重置Matrix mMatrix.reset(); // 计算图片旋转角度 float degrees = (float) (Math.atan2(tan[1], tan[0]) * 180.0 / Math.PI); // 旋转图片 mMatrix.postRotate(degrees, mBitmap.getWidth() / 2, mBitmap.getHeight() / 2); // 将图片绘制中心调整到与当前点重合 mMatrix.postTranslate(pos[0] - mBitmap.getWidth() / 2, pos[1] - mBitmap.getHeight() / 2); // 方案二 // 获取当前位置的坐标以及趋势的矩阵 //measure.getMatrix(measure.getLength() * currentValue, mMatrix, //PathMeasure.TANGENT_MATRIX_FLAG | PathMeasure.POSITION_MATRIX_FLAG); // 将图片绘制中心调整到与当前点重合(注意:此处是前乘pre) //mMatrix.preTranslate(-mBitmap.getWidth() / 2, -mBitmap.getHeight() / 2); canvas.drawPath(path, mDeafultPaint); canvas.drawBitmap(mBitmap, mMatrix, mDeafultPaint); invalidate();&#125;&#125; 那么其他API基础使用大家可以参考网上的说明，以及文档资料.]]></content>
      <categories>
        <category>android</category>
        <category>ui</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ui</tag>
        <tag>Path</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[贝塞尔曲线]]></title>
    <url>%2FMy-New-Post%2F</url>
    <content type="text"><![CDATA[前言相信很多同学都知道“[贝塞尔曲线]”这个词，我们在很多地方都能经常看到。但是，可能并不是每位同学都清楚地知道，到底什么是“贝塞尔曲线”，又是什么特点让它有这么高的知名度。 贝塞尔曲线的数学基础是早在 1912 年就广为人知的[伯恩斯坦多项式]。但直到 1959 年，当时就职于雪铁龙的法国数学家 [Paul de Casteljau]才开始对它进行图形化应用的尝试，并提出了一种数值稳定的 [de Casteljau 算法]。然而贝塞尔曲线的得名，却是由于 1962 年另一位就职于雷诺的法国工程师 [Pierre Bézier]的广泛宣传。他使用这种只需要很少的控制点就能够生成复杂平滑曲线的方法，来辅助汽车车体的工业设计。 正是因为控制简便却具有极强的描述能力，贝塞尔曲线在工业设计领域迅速得到了广泛的应用。不仅如此，在计算机图形学领域，尤其是矢量图形学，贝塞尔曲线也占有重要的地位。今天我们最常见的一些矢量绘图软件，如 Flash、Illustrator、CorelDraw 等，无一例外都提供了绘制贝塞尔曲线的功能。甚至像 Photoshop 这样的位图编辑软件，也把贝塞尔曲线作为仅有的矢量绘制工具（钢笔工具）包含其中。 贝塞尔曲线(Bézier curve)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。贝塞尔曲线是计算机图形学中相当重要的参数曲线，在一些比较成熟的位图软件中也有贝塞尔曲线工具，如PhotoShop等。在Flash4中还没有完整的曲线工具，而在Flash5里面已经提供出贝塞尔曲线工具。 好吧，我承认上面是一组废话， 来源于百科，那么其实想要真正了解什么是贝塞尔曲线，我们首先来明白他到底是什么， 贝塞尔曲线详解本质概念：一组算法目的：这组算法用来干什么？核心：通过这组算法，我门能达到什么效果 那么首先我门来看最基础的一介贝塞尔 一介贝塞尔 一阶贝塞尔曲线的核心目的其实就只是由两点控制的一条直线 二阶贝塞尔曲线是由一个控制点去控制一条的曲线,而曲线的运动是由两个直线所控制 二介贝塞尔绘制过程image.png那么这里相信有很多同学对于上图比较的懵，接下来我们将上图拆解出来分析 image.png那么此时贝塞尔曲线的计算规则是由A-C &amp; B-C进行连线 image.png然后在AC线段和BC线段进行等比定位 画的不是太标准，但是AC CB 定位点的位置的比例需要一致然后由AC上的点和CB上的点进行连接，在选取这条线段上同AC CB比例相同的点 image.png那么这个点就是绘制贝塞尔曲线的点 image.png我们的整条曲线是从AC线段开始绘制，通过Path路径进行绘制，如下图 二介贝塞尔绘制过程那么此时如果你还不明白，或者是你们受不了我的图纸了，那么看下面 实际线条是从A开始到C结束绘制过程由A点开始，例：D点和A点成一个百分比那么这里BC线段上同样出现BE这两个点，百分比和AD一致在经由这两个点连线出现DE这条线，那么在从这条线上面取得同AD,BE的比例的点F那么当前这个点就是当前绘制的这一个点我们由A-C开始启动绘制，用PATH记录点进行绘制，从而得到一条曲线，这条曲线就是我们的贝塞尔曲线PS:哎，如果在这里才懂得同学你们就让我伤心了，果然还是别人画的图比我画的好看。 那么此时其实我们对于之前的在百度百科上看到的贝塞尔算法 二阶算法.png 三阶算法.png这种算法可以直接忽略了，因为看的蛋疼 我们直接通过下图得出]]></content>
      <categories>
        <category>android</category>
        <category>ui</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ui</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C指针]]></title>
    <url>%2FcPoint%2F</url>
    <content type="text"><![CDATA[前言学习 C 语言的指针既简单又有趣。通过指针，可以简化一些 C 编程任务的执行，还有一些任务，如动态内存分配，没有指针是无法执行的。所以，想要成为一名优C 程序员，学习指针是很有必要的。 正如您所知道的，每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&amp;）运算符访问的地址，它表示了在内存中的一个地址。请看下面的实例，它将输出定义的变量地址： 123456789101112#include &lt;stdio.h&gt; int main ()&#123; int var1; char var2[10]; printf("var1 变量的地址： %p\n", &amp;var1 ); printf("var2 变量的地址： %p\n", &amp;var2 ); return 0;&#125; 结果： 12var1 变量的地址： 002CF9BCvar2 变量的地址： 002CF9A8 什么是指针？指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。就像其他变量或常量一样，您必须在使用指针存储其他变量地址之前，对其进行声明。指针变量声明的一般形式为： 1type *var-name; 在这里，type 是指针的基类型，它必须是一个有效的 C 数据类型，var-name 是指针变量的名称。用来声明指针的星号 * 与乘法中使用的星号是相同的。但是，在这个语句中，星号是用来指定一个变量是指针。以下是有效的指针声明： 1234int *ip; /* 一个整型的指针 */double *dp; /* 一个 double 型的指针 */float *fp; /* 一个浮点型的指针 */char *ch; /* 一个字符型的指针 */ 所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。 如何使用指针？使用指针时会频繁进行以下几个操作：定义一个指针变量、把变量地址赋值给指针、访问指针变量中可用地址的值。这些是通过使用一元运算符 * 来返回位于操作数所指定地址的变量的值。下面的实例涉及到了这些操作： 1234567891011121314151617181920212223#include &lt;stdarg.h&gt;int main()&#123; int str = 500; /* 实际变量的声明 */ int *ip; /* 指针变量的声明 */ ip = &amp;str; /* 在指针变量中存储 var 的地址 */ printf("Address of var variable: %p\n", &amp;str); /* 在指针变量中存储的地址 */ printf("Address stored in ip variable: %p\n", ip); /* 使用指针访问值 */ printf("Value of *ip variable: %d\n", *ip); system("pause"); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1234Address of var variable: 0026F74CAddress stored in ip variable: 0026F74CValue of *ip variable: 500请按任意键继续. . . C 中的 NULL 指针在变量声明的时候，如果没有确切的地址可以赋值，为指针变量赋一个 NULL 值是一个良好的编程习惯。赋为 NULL 值的指针被称为空指针。 NULL 指针是一个定义在标准库中的值为零的常量。请看下面的程序： 1234567int main()&#123; int *ptr = NULL; printf("ptr 的地址是 %p\n", ptr); system("pause"); return 0;&#125; 执行结果 12ptr 的地址是 00000000请按任意键继续. . . 在大多数的操作系统上，程序不允许访问地址为 0 的内存，因为该内存是操作系统保留的。然而，内存地址 0 有特别重要的意义，它表明该指针不指向一个可访问的内存位置。但按照惯例，如果指针包含空值（零值），则假定它不指向任何东西。 如需检查一个空指针，您可以使用 if 语句，如下所示： 12if(ptr) /* 如果 p 非空，则完成 */if(!ptr) /* 如果 p 为空，则完成 */ 指针的算术运算C 指针是一个用数值表示的地址。因此，您可以对指针执行算术运算。可以对指针进行四种算术运算：++、–、+、-。 假设 ptr 是一个指向地址 1000 的整型指针，是一个 32 位的整数，让我们对该指针执行下列的算术运算：1ptr++ 在执行完上述的运算之后，ptr 将指向位置 1004，因为 ptr 每增加一次，它都将指向下一个整数位置，即当前位置往后移 4 个字节。这个运算会在不影响内存位置中实际值的情况下，移动指针到下一个内存位置。如果 ptr 指向一个地址为 1000 的字符，上面的运算会导致指针指向位置 1001，因为下一个字符位置是在 1001。 递增一个指针 和 递减一个指针这里举例为递增我们喜欢在程序中使用指针代替数组，因为变量指针可以递增，而数组不能递增，因为数组是一个常量指针。下面的程序递增变量指针，以便顺序访问数组中的每一个元素： 1234567891011121314151617181920212223#include &lt;stdarg.h&gt;const int MAX = 3;int main()&#123; int var[] = &#123; 10, 100, 200 &#125;; int i, *ptr; /* 指针中的数组地址 */ ptr = var; for (i = 0; i &lt; MAX; i++) &#123; printf("存储地址：var[%d] = %x\n", i, ptr); printf("存储值：var[%d] = %d\n", i, *ptr); /* 移动到下一个位置 */ ptr++; &#125; system("pause"); return 0;&#125; 执行结果 1234567存储地址：var[0] = 32fe2c存储值：var[0] = 10存储地址：var[1] = 32fe30存储值：var[1] = 100存储地址：var[2] = 32fe34存储值：var[2] = 200请按任意键继续. . . 指针的比较指针可以用关系运算符进行比较，如 ==、&lt; 和 &gt;。如果 p1 和 p2 指向两个相关的变量，比如同一个数组中的不同元素，则可对 p1 和 p2 进行大小比较。 下面的程序修改了上面的实例，只要变量指针所指向的地址小于或等于数组的最后一个元素的地址 &amp;var[MAX - 1]，则把变量指针进行递增： 123456789101112131415161718192021#include &lt;stdio.h&gt;const int MAX = 3;int main ()&#123; int var[] = &#123;10, 100, 200&#125;; int i, *ptr; /* 指针中第一个元素的地址 */ ptr = var; i = 0; while ( ptr &lt;= &amp;var[MAX - 1] ) &#123; printf("Address of var[%d] = %x\n", i, ptr ); printf("Value of var[%d] = %d\n", i, *ptr ); /* 指向上一个位置 */ ptr++; i++; &#125; return 0;&#125; 执行结果 123456Address of var[0] = bfdbcb20Value of var[0] = 10Address of var[1] = bfdbcb24Value of var[1] = 100Address of var[2] = bfdbcb28Value of var[2] = 200 数组指针 和 指针数组12345678910int main ()&#123; // 数组 的 指针 int array2[2][3] = &#123; &#123; 11,22,33 &#125;,&#123; 44,55,66 &#125; &#125;; //数组指针 int[3] * int(*array_p2)[3] = array2; // 指针 的 数组 //int *p_array[3] = &#123; &amp;i1,&amp;i1,&amp;i1 &#125;; return 0;&#125; 执行结果123array_p2 + 1: 0x1bfc34取出55：55请按任意键继续. . . 传递指针给函数请看注释 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748#include &lt;stdbool.h&gt;// lsn2_example.cpp: 定义应用程序的入口点。//#include &lt;stdarg.h&gt;const int MAX = 3;// lsn2_example.cpp: 定义应用程序的入口点。//using namespace std;void change1(int i) &#123; i = 10;&#125;void change2(int* i) &#123; *i = 10;&#125;void change3(int** i) &#123; int j = 100; *i = &amp;j;&#125;int main()&#123; //函数形参 //1、传值 //把参数的值给函数 int i3 = 1; change1(i3); printf("change1 i3=%d\n", i3); //2、传引用 //不修改指针的值 修改的是指针指向内存的数据 int *p9 = &amp;i3; //修改i3的值 change2(p9); printf("change2 i3=%d\n", i3); //p9这个变量的地址给 p10 int **p10 = &amp;p9; printf("p9 p9地址为：%p\n", p9); //修改指针的值 p9的值 0xXXXXX 地址 change3(p10); printf("change3 **p10=%d\n", **p10); system("pause"); return 0;&#125; 执行结果12345change1 i3=1change2 i3=10p9 p9地址为：00000000002AFD04change3 **p10=100请按任意键继续. . .]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android：一定能成功的Android NDK环境配置教程]]></title>
    <url>%2FconfigNdk%2F</url>
    <content type="text"><![CDATA[前言 在Android开发中，使用 NDK开发的需求正逐渐增大 但在Android使用NDK前需要进行 相关环境配置 本文主要讲解 在Mac情况下的Android NDK配置，希望你们会喜欢 步骤说明 下面，我将一步步讲解如何进行NDK环境配置。 2. 步骤讲解步骤1. 下载Android NDK工具包 官网下载地址，注意 科学 上网 本文采用的Android NDK版本是：android-ndk-r14b-darwin-x86_64 步骤2： 解压 NDK包 注：解压路径 不要出现空格和中文 建议：将解压路径设置为：Android Studio的SDK目录里，并命名为ndk-bundle 123456789解压路径：/Users/Carson_Ho/Library/Android/sdk/ndk-bundle``` ![](configNdk/three.png)* 好处：启动Android Studio时，Android Studio会自动检查它并直接添加到ndk.dir中，那么在使用时，就不用配置Android Studio与NDK的关联工作## 步骤3：安装 &amp; 配置NDK在终端依次输入下列命令 // 先输入以下命令pico .bash_profile // 再依次输入下列命令（后面的路径需要根据你NDK解压路径设置）export PATH=${PATH}:/Users/Carson_Ho/Library/Android/sdk/ndk-bundleA_NDK_ROOT=/Users/Carson_Ho/Library/Android/sdk/ndk-bundleexport A_NDK_ROOT// 注意检查空格、中 &amp; 英字符区分 // 输入以下组合命令 进行保存control＋X// 输入后，选择Y // 最后，更新刚配置的环境变量source .bash_profile // 验证NDK是否配置成功 // 1. 关闭终端 并 重新打开 // 2. 若无错误提示，则成功配置` 至此，关于Android NDK的环境配置已经完成 总结 本文主要讲解Android的NDK相关知识 关于Android 的NDK使用 请参考文章： Android：JNI 与 NDK到底是什么？（含实例教学） 下面我将继续对 Android中的NDK进行深入讲解 ，有兴趣可以继续关注]]></content>
      <categories>
        <category>android</category>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 友元(友元函数、友元类和友元成员函数)]]></title>
    <url>%2FC-friend%2F</url>
    <content type="text"><![CDATA[前言有些情况下，允许特定的非成员函数访问一个类的私有成员，同时仍阻止一般的访问，这是很方便做到的。例如被重载的操作符，如输入或输出操作符，经常需要访问类的私有数据成员。友元(friend)机制允许一个类将对其非公有成员的访问权授予指定的函数或者类，友元的声明以friend开始，它只能出现在类定义的内部，友元声明可以出现在类中的任何地方：友元不是授予友元关系的那个类的成员，所以它们不受其声明出现部分的访问控制影响。通常，将友元声明成组地放在类定义的开始或结尾是个好主意。 友元函数 友元函数是指某些虽然不是类成员函数却能够访问类的所有成员的函数。类授予它的友元特别的访问权，这样该友元函数就能访问到类中的所有成员。 12345678910111213141516171819202122232425#include &lt;iostream&gt;using namespace std;class A&#123;public: friend void set_show(int x, A &amp;a); //该函数是友元函数的声明private: int data;&#125;;void set_show(int x, A &amp;a) //友元函数定义，为了访问类A中的成员&#123; a.data = x; cout &lt;&lt; a.data &lt;&lt; endl;&#125;int main(void)&#123; class A a; set_show(1, a); return 0;&#125; 友元类 友元类的所有成员函数都是另一个类的友元函数，都可以访问另一个类中的隐藏信息（包括私有成员和保护成员）。当希望一个类可以存取另一个类的私有成员时，可以将该类声明为另一类的友元类。关于友元类的注意事项： (1) 友元关系不能被继承。(2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。(3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明 123456789101112131415161718192021222324252627#include &lt;iostream&gt;using namespace std;class A&#123;public: friend class C; //这是友元类的声明private: int data;&#125;;class C //友元类定义，为了访问类A中的成员&#123;public: void set_show(int x, A &amp;a) &#123; a.data = x; cout&lt;&lt;a.data&lt;&lt;endl;&#125;&#125;;int main(void)&#123; class A a; class C c; c.set_show(1, a); return 0;&#125; 友元成员函数 使类B中的成员函数成为类A的友元函数，这样类B的该成员函数就可以访问类A的所有成员了。当用到友元成员函数时，需注意友元声明和友元定义之间的相互依赖，在该例子中，类B必须先定义，否则类A就不能将一个B的函数指定为友元。然而，只有在定义了类A之后，才能定义类B的该成员函数。更一般的讲，必须先定义包含成员函数的类，才能将成员函数设为友元。另一方面，不必预先声明类和非成员函数来将它们设为友元。 1234567891011121314151617181920212223242526272829303132333435#include &lt;iostream&gt;using namespace std;class A; //当用到友元成员函数时，需注意友元声明与友元定义之间的互相依赖。这是类A的声明class B&#123;public: void set_show(int x, A &amp;a); //该函数是类A的友元函数&#125;;class A&#123;public: friend void B::set_show(int x, A &amp;a); //该函数是友元成员函数的声明private: int data; void show() &#123; cout &lt;&lt; data &lt;&lt; endl; &#125;&#125;;void B::set_show(int x, A &amp;a) //只有在定义类A后才能定义该函数，毕竟，它被设为友元是为了访问类A的成员&#123; a.data = x; cout &lt;&lt; a.data &lt;&lt; endl;&#125;int main(void)&#123; class A a; class B b; b.set_show(1, a); return 0;&#125; 友元小结 在需要允许某些特定的非成员函数访问一个类的私有成员（及受保护成员），而同时仍阻止一般的访问的情况下，友元是可用的。 优点： 123456可以灵活地实现需要访问若干类的私有或受保护的成员才能完成的任务；便于与其他不支持类概念的语言(如C语言、汇编等)进行混合编程；通过使用友元函数重载可以更自然地使用C++语言的IO流库。 缺点： 1一个类将对其非公有成员的访问权限授予其他函数或者类，会破坏该类的封装性，降低该类的可靠性和可维护性。]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++_OverLoaded]]></title>
    <url>%2FC-OverLoaded%2F</url>
    <content type="text"><![CDATA[C++ 重载运算符和重载函数 C++ 允许在同一作用域中的某个函数和运算符指定多个定义，分别称为函数重载和运算符重载。重载声明是指一个与之前已经在该作用域内声明过的函数或方法具有相同名称的声明，但是它们的参数列表和定义（实现）不相同。当您调用一个重载函数或重载运算符时，编译器通过把您所使用的参数类型与定义中的参数类型进行比较，决定选用最合适的定义。选择最合适的重载函数或重载运算符的过程，称为重载决策。 C++ 中的函数重载 在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的形式参数（指参数的个数、类型或者顺序）必须不同。您不能仅通过返回类型的不同来重载函数。下面的实例中，同名函数 print() 被用于输出不同的数据类型： 123456789101112131415161718192021222324252627282930313233#include &lt;iostream&gt;using namespace std; class printData&#123; public: void print(int i) &#123; cout &lt;&lt; "整数为: " &lt;&lt; i &lt;&lt; endl; &#125; void print(double f) &#123; cout &lt;&lt; "浮点数为: " &lt;&lt; f &lt;&lt; endl; &#125; void print(char c[]) &#123; cout &lt;&lt; "字符串为: " &lt;&lt; c &lt;&lt; endl; &#125;&#125;; int main(void)&#123; printData pd; // 输出整数 pd.print(5); // 输出浮点数 pd.print(500.263); // 输出字符串 char c[] = "Hello C++"; pd.print(c); return 0;&#125; Result: 123整数为: 5浮点数为: 500.263字符串为: Hello C++ C++ 中的运算符重载 您可以重定义或重载大部分 C++ 内置的运算符。这样，您就能使用自定义类型的运算符。 重载的运算符是带有特殊名称的函数，函数名是由关键字 operator 和其后要重载的运算符符号构成的。与其他函数一样，重载运算符有一个返回类型和一个参数列表。 1Box operator+(const Box&amp;); 声明加法运算符用于把两个 Box 对象相加，返回最终的 Box 对象。大多数的重载运算符可被定义为普通的非成员函数或者被定义为类成员函数。如果我们定义上面的函数为类的非成员函数，那么我们需要为每次操作传递两个参数，如下所示： 1Box operator+(const Box&amp;, const Box&amp;); 下面的实例使用成员函数演示了运算符重载的概念。在这里，对象作为参数进行传递，对象的属性使用 this 运算符进行访问，如下所示： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374#include &lt;iostream&gt;using namespace std; class Box&#123; public: double getVolume(void) &#123; return length * breadth * height; &#125; void setLength( double len ) &#123; length = len; &#125; void setBreadth( double bre ) &#123; breadth = bre; &#125; void setHeight( double hei ) &#123; height = hei; &#125; // 重载 + 运算符，用于把两个 Box 对象相加 Box operator+(const Box&amp; b) &#123; Box box; box.length = this-&gt;length + b.length; box.breadth = this-&gt;breadth + b.breadth; box.height = this-&gt;height + b.height; return box; &#125; private: double length; // 长度 double breadth; // 宽度 double height; // 高度&#125;;// 程序的主函数int main( )&#123; Box Box1; // 声明 Box1，类型为 Box Box Box2; // 声明 Box2，类型为 Box Box Box3; // 声明 Box3，类型为 Box double volume = 0.0; // 把体积存储在该变量中 // Box1 详述 Box1.setLength(6.0); Box1.setBreadth(7.0); Box1.setHeight(5.0); // Box2 详述 Box2.setLength(12.0); Box2.setBreadth(13.0); Box2.setHeight(10.0); // Box1 的体积 volume = Box1.getVolume(); cout &lt;&lt; "Volume of Box1 : " &lt;&lt; volume &lt;&lt;endl; // Box2 的体积 volume = Box2.getVolume(); cout &lt;&lt; "Volume of Box2 : " &lt;&lt; volume &lt;&lt;endl; // 把两个对象相加，得到 Box3 Box3 = Box1 + Box2; // Box3 的体积 volume = Box3.getVolume(); cout &lt;&lt; "Volume of Box3 : " &lt;&lt; volume &lt;&lt;endl; return 0;&#125; Result: 123Volume of Box1 : 210Volume of Box2 : 1560Volume of Box3 : 5400 可重载运算符/不可重载运算符下面是可重载的运算符列表：下面用1代替| 类型 运算符 双目算术运算符 + (加)，-(减)，*(乘)，/(除)，% (取模) 关系运算符 ==(等于)，!= (不等于)，&lt; (小于)，&gt; (大于&gt;，&lt;=(小于等于)，&gt;=(大于等于) 逻辑运算符 11(逻辑或)，&amp;&amp;(逻辑与)，!(逻辑非) 单目运算符 + (正)，-(负)，*(指针)，&amp;(取地址) 自增自减运算符 ++(自增)，–(自减) 位运算符 1(按位或)，&amp; (按位与)，~(按位取反)，^(按位异或),，&lt;&lt; (左移)，&gt;&gt;(右移) 赋值运算符 =, +=, -=, *=, /= , % = , &amp;=, 1=, ^=, &lt;&lt;=, &gt;&gt;= 空间申请与释放 new, delete, new[ ] , delete[] 其他运算符 ()(函数调用)，-&gt;(成员访问)，,(逗号)， 下面是不可重载的运算符列表： .：成员访问运算符 .*, -&gt;*：成员指针访问运算符 ::：域运算符 sizeof：长度运算符 ?:：条件运算符 #： 预处理符号 值得注意的是: 1.运算重载符不可以改变语法结构。2.运算重载符不可以改变操作数的个数。3.运算重载符不可以改变优先级。4.运算重载符不可以改变结合性。]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 继承]]></title>
    <url>%2FC-Inherit%2F</url>
    <content type="text"><![CDATA[前言继承是面向对象程序设计中最重要的概念之一。继承允许我们根据一个类来定义另一个类，这使得创建和维护应用程序变得更容易。同时也有利于重用代码和节省开发时间。 当创建一个类时，程序员不需要完全重新编写新的数据成员和成员函数，只需要设计一个新的类，继承了已有的类的成员即可。这个已有的类被称为的基类，这个新的类被称为派生类。 继承的思想实现了 属于（IS-A） 关系。例如，哺乳动物 属于（IS-A） 动物，狗 属于（IS-A） 哺乳动物，因此狗 属于（IS-A） 动物。 基类和派生类一个类可以派生自多个类或接口，这意味着它可以从多个基类或接口继承数据和函数。 C# 中创建派生类的语法如下：12345678&lt;acess-specifier&gt; class &lt;base_class&gt;&#123; ...&#125;class &lt;derived_class&gt; : &lt;base_class&gt;&#123; ...&#125; 假设，有一个基类 Shape，它的派生类是 Rectangle： 1234567891011121314151617181920212223242526272829303132333435363738394041using System;namespace InheritanceApplication&#123; class Shape &#123; public void setWidth(int w) &#123; width = w; &#125; public void setHeight(int h) &#123; height = h; &#125; protected int width; protected int height; &#125; // 派生类 class Rectangle: Shape &#123; public int getArea() &#123; return (width * height); &#125; &#125; class RectangleTester &#123; static void Main(string[] args) &#123; Rectangle Rect = new Rectangle(); Rect.setWidth(5); Rect.setHeight(7); // 打印对象的面积 Console.WriteLine("总面积： &#123;0&#125;", Rect.getArea()); Console.ReadKey(); &#125; &#125;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1总面积： 35 基类的初始化派生类继承了基类的成员变量和成员方法。因此父类对象应在子类对象创建之前被创建。您可以在成员初始化列表中进行父类的初始化。 下面的程序演示了这点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;namespace RectangleApplication&#123; class Rectangle &#123; // 成员变量 protected double length; protected double width; public Rectangle(double l, double w) &#123; length = l; width = w; &#125; public double GetArea() &#123; return length * width; &#125; public void Display() &#123; Console.WriteLine("长度： &#123;0&#125;", length); Console.WriteLine("宽度： &#123;0&#125;", width); Console.WriteLine("面积： &#123;0&#125;", GetArea()); &#125; &#125;//end class Rectangle class Tabletop : Rectangle &#123; private double cost; public Tabletop(double l, double w) : base(l, w) &#123; &#125; public double GetCost() &#123; double cost; cost = GetArea() * 70; return cost; &#125; public void Display() &#123; base.Display(); Console.WriteLine("成本： &#123;0&#125;", GetCost()); &#125; &#125; class ExecuteRectangle &#123; static void Main(string[] args) &#123; Tabletop t = new Tabletop(4.5, 7.5); t.Display(); Console.ReadLine(); &#125; &#125;&#125; Result: 1234长度： 4.5宽度： 7.5面积： 33.75成本： 2362.5 C# 多重继承多重继承指的是一个类别可以同时从多于一个父类继承行为与特征的功能。与单一继承相对，单一继承指一个类别只可以继承自一个父类。 C# 不支持多重继承。但是，您可以使用接口来实现多重继承。下面的程序演示了这点： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;namespace InheritanceApplication&#123; class Shape &#123; public void setWidth(int w) &#123; width = w; &#125; public void setHeight(int h) &#123; height = h; &#125; protected int width; protected int height; &#125; // 基类 PaintCost public interface PaintCost &#123; int getCost(int area); &#125; // 派生类 class Rectangle : Shape, PaintCost &#123; public int getArea() &#123; return (width * height); &#125; public int getCost(int area) &#123; return area * 70; &#125; &#125; class RectangleTester &#123; static void Main(string[] args) &#123; Rectangle Rect = new Rectangle(); int area; Rect.setWidth(5); Rect.setHeight(7); area = Rect.getArea(); // 打印对象的面积 Console.WriteLine("总面积： &#123;0&#125;", Rect.getArea()); Console.WriteLine("油漆总成本： $&#123;0&#125;" , Rect.getCost(area)); Console.ReadKey(); &#125; &#125;&#125; Result:12总面积： 35油漆总成本： $2450]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C# 命名空间（Namespace）]]></title>
    <url>%2FC-Namespace%2F</url>
    <content type="text"><![CDATA[前言命名空间的设计目的是提供一种让一组名称与其他名称分隔开的方式。在一个命名空间中声明的类的名称与另一个命名空间中声明的相同的类的名称不冲突。 定义命名空间命名空间的定义是以关键字 namespace 开始，后跟命名空间的名称，如下所示： 1234namespace namespace_name&#123; // 代码声明&#125; 为了调用支持命名空间版本的函数或变量，会把命名空间的名称置于前面，如下所示： 1namespace_name.item_name; 下面的程序演示了命名空间的用法： 1234567891011121314151617181920212223242526272829303132using System;namespace first_space&#123; class namespace_cl &#123; public void func() &#123; Console.WriteLine("Inside first_space"); &#125; &#125;&#125;namespace second_space&#123; class namespace_cl &#123; public void func() &#123; Console.WriteLine("Inside second_space"); &#125; &#125;&#125; class TestClass&#123; static void Main(string[] args) &#123; first_space.namespace_cl fc = new first_space.namespace_cl(); second_space.namespace_cl sc = new second_space.namespace_cl(); fc.func(); sc.func(); Console.ReadKey(); &#125;&#125; Result: 12Inside first_spaceInside second_space using 关键字using 关键字表明程序使用的是给定命名空间中的名称。例如，我们在程序中使用 System 命名空间，其中定义了类 Console。我们可以只写： 1Console.WriteLine ("Hello there"); 我们可以写完全限定名称，如下：1System.Console.WriteLine ("Hello there"); 您也可以使用 using 命名空间指令，这样在使用的时候就不用在前面加上命名空间名称。该指令告诉编译器随后的代码使用了指定命名空间中的名称。下面的代码演示了命名空间的应用。 让我们使用 using 指定重写上面的实例： 1234567891011121314151617181920212223242526272829303132333435using System;using first_space;using second_space;namespace first_space&#123; class abc &#123; public void func() &#123; Console.WriteLine("Inside first_space"); &#125; &#125;&#125;namespace second_space&#123; class efg &#123; public void func() &#123; Console.WriteLine("Inside second_space"); &#125; &#125;&#125; class TestClass&#123; static void Main(string[] args) &#123; abc fc = new abc(); efg sc = new efg(); fc.func(); sc.func(); Console.ReadKey(); &#125;&#125; Result: 12Inside first_spaceInside second_space 嵌套命名空间命名空间可以被嵌套，即您可以在一个命名空间内定义另一个命名空间，如下所示： 12345678namespace namespace_name1 &#123; // 代码声明 namespace namespace_name2 &#123; // 代码声明 &#125;&#125; 您可以使用点（.）运算符访问嵌套的命名空间的成员，如下所示： 123456789101112131415161718192021222324252627using System;using SomeNameSpace;using SomeNameSpace.Nested;namespace SomeNameSpace&#123; public class MyClass &#123; static void Main() &#123; Console.WriteLine("In SomeNameSpace"); Nested.NestedNameSpaceClass.SayHello(); &#125; &#125; // 内嵌命名空间 namespace Nested &#123; public class NestedNameSpaceClass &#123; public static void SayHello() &#123; Console.WriteLine("In Nested"); &#125; &#125; &#125;&#125; Result:12In SomeNameSpaceIn Nested ————-本文结束感谢您的阅读————-自己练习的demo 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105#include "a.h"namespace A &#123; namespace B &#123; void test() &#123; &#125; &#125;&#125;using namespace std;using namespace A;using namespace A::B;void change(int&amp; j) &#123; j = 11;&#125;int ii;int main()&#123; ii = 11; int ii = 10; cout &lt;&lt; ii &lt;&lt; endl; //操作重名的全局变量的时候 可以使用域作用符 cout &lt;&lt; ::ii &lt;&lt; endl; ::ii = 88; ii = 11; cout &lt;&lt; ::ii &lt;&lt; endl; //:: 域作用符 A::B::test(); B::test(); test(); cout &lt;&lt; "Hello CMake。" &lt;&lt; endl; // 1、c与c++ 兼容 test(1,2); //2、 引用 int i = 10; // int&amp; 引用类型 // 10这个内存地址 给了个别名 j int&amp; j = i; change(j); cout &lt;&lt; i &lt;&lt; endl; cout &lt;&lt; j &lt;&lt; endl; // i是一个标签， 再创建一个j标签 表示 10 保存的地址 //3、字符串 //c 使用 NULL \0 结尾的一个字符数组 char c_str1[] = &#123; 'h','e','l','\0' &#125;; //默认给我们在末尾增加 \0 char *c_str2 = "hello"; cout &lt;&lt; "c_str1:" &lt;&lt; c_str1 &lt;&lt; endl; cout &lt;&lt; "c_str2:" &lt;&lt; c_str2 &lt;&lt; endl; char c_str3[10]; strcpy(c_str3, c_str1); cout &lt;&lt; "c_str3:" &lt;&lt; c_str3 &lt;&lt; endl; //c++ string 类 #include &lt;string&gt; string str1 = "hello"; //调用构造方法 string str2(str1); string str3("天之道"); //申请内存 调用构造方法 string *str4 = new string("David爱去找88号技师"); // 拼接字符串 // + 操作符重载:重新定义 的 行为 string str5 = str1 + str3; str1.append(str3); //获得c的字符串 cout &lt;&lt; str1.c_str() &lt;&lt; endl; //获得字符串长度 str1.size(); str1.empty(); //...... // 1、出方法 清理栈 // 2、指针 4/8 对象 x个字节 效率更高 str4-&gt;c_str(); //4、命名空间 package //释放内存 delete str4; //malloc = free // new = delete // new 数组 = delete[] system("pause"); return 0;&#125;]]></content>
      <categories>
        <category>c#</category>
      </categories>
      <tags>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 共用体]]></title>
    <url>%2Fc-union%2F</url>
    <content type="text"><![CDATA[前言共用体是一种特殊的数据类型，允许您在相同的内存位置存储不同的数据类型。您可以定义一个带有多成员的共用体，但是任何时候只能有一个成员带有值。共用体提供了一种使用相同的内存位置的有效方式 定义共用体为了定义共用体，您必须使用 union 语句，方式与定义结构类似。union 语句定义了一个新的数据类型，带有多个成员。union 语句的格式如下： 1234567union [union tag]&#123; member definition; member definition; ... member definition;&#125; [one or more union variables]; union tag 是可选的，每个 member definition 是标准的变量定义，比如 int i; 或者 float f; 或者其他有效的变量定义。在共用体定义的末尾，最后一个分号之前，您可以指定一个或多个共用体变量，这是可选的。下面定义一个名为 Data 的共用体类型，有三个成员 i、f 和 str： 123456union Data&#123; int i; float f; char str[20];&#125; data; 现在，Data 类型的变量可以存储一个整数、一个浮点数，或者一个字符串。这意味着一个变量（相同的内存位置）可以存储多个多种类型的数据。您可以根据需要在一个共用体内使用任何内置的或者用户自定义的数据类型。 共用体占用的内存应足够存储共用体中最大的成员。例如，在上面的实例中，Data 将占用 20 个字节的内存空间，因为在各个成员中，字符串所占用的空间是最大的。下面的实例将显示上面的共用体占用的总内存大小：123456789101112131415161718#include &lt;stdio.h&gt;#include &lt;string.h&gt; union Data&#123; int i; float f; char str[20];&#125;; int main( )&#123; union Data data; printf( "Memory size occupied by data : %d\n", sizeof(data)); return 0;&#125; Result： 1Memory size occupied by data : 20 访问共用体成员为了访问共用体的成员，我们使用成员访问运算符（.）。成员访问运算符是共用体变量名称和我们要访问的共用体成员之间的一个句号。您可以使用 union 关键字来定义共用体类型的变量。下面的实例演示了共用体的用法： 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt; union Data&#123; int i; float f; char str[20];&#125;; int main( )&#123; union Data data; data.i = 10; data.f = 220.5; strcpy( data.str, "C Programming"); printf( "data.i : %d\n", data.i); printf( "data.f : %f\n", data.f); printf( "data.str : %s\n", data.str); return 0;&#125; Result： 123data.i : 1917853763data.f : 4122360580327794860452759994368.000000data.str : C Programming 在这里，我们可以看到共用体的 i 和 f 成员的值有损坏，因为最后赋给变量的值占用了内存位置，这也是 str 成员能够完好输出的原因。现在让我们再来看一个相同的实例，这次我们在同一时间只使用一个变量，这也演示了使用共用体的主要目的： 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;string.h&gt; union Data&#123; int i; float f; char str[20];&#125;; int main( )&#123; union Data data; data.i = 10; printf( "data.i : %d\n", data.i); data.f = 220.5; printf( "data.f : %f\n", data.f); strcpy( data.str, "C Programming"); printf( "data.str : %s\n", data.str); return 0;&#125; Result： 123data.i : 10data.f : 220.500000data.str : C Programming 在这里，所有的成员都能完好输出，因为同一时间只用到一个成员。]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 结构体]]></title>
    <url>%2Fc-struct%2F</url>
    <content type="text"><![CDATA[前言C 数组允许定义可存储相同类型数据项的变量，结构是 C 编程中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。这里可以理解在Android中的javabean 定义结构为了定义结构，您必须使用 struct 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下： 12345struct Student &#123; int i char j ...&#125; stu ; Student 是结构体标签。 是标准的变量定义，比如 int i; 或者 float f，或者其他有效的变量定义 stu 结构变量，定义在结构的末尾，最后一个分号之前，您可以指定一个或多个结构变量。下面是声明 Book 结构的方式 1234567struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125; book; 在一般情况下，Student、int i、stu 这 3 部分至少要出现 2 个。以下为实例：1这个结构体并没有标明其标签 此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c 同时又声明了结构体变量s1 123456struct &#123; int a; char b; double c;&#125; s1; 2结构体的标签被命名为SIMPLE,没有声明变量此声明声明了拥有3个成员的结构体，分别为整型的a，字符型的b和双精度的c 123456struct SIMPLE&#123; int a; char b; double c;&#125;; 3用SIMPLE标签的结构体，另外声明了变量t1、t2、t31struct SIMPLE t1, t2[20], *t3; 4也可以用typedef创建新类型12345678typedef struct&#123; int a; char b; double c; &#125; Simple2;//现在可以用Simple2作为类型声明新的结构体变量Simple2 u1, u2[20], *u3; 在上面的声明中，第一个和第二声明被编译器当作两个完全不同的类型，即使他们的成员列表是一样的，如果令 t3=&amp;s1，则是非法的。 结构体的成员可以包含其他结构体，也可以包含指向自己结构体类型的指针，而通常这种指针的应用是为了实现一些更高级的数据结构如链表和树等。 12345678910111213//此结构体的声明包含了其他的结构体struct COMPLEX&#123; char string[100]; struct SIMPLE a;&#125;; //此结构体的声明包含了指向自己类型的指针struct NODE&#123; char string[100]; struct NODE *next_node;&#125;; 如果两个结构体互相包含，则需要对其中一个结构体进行不完整声明，如下所示： 123456789struct B; //对结构体B进行不完整声明 //结构体A中包含指向结构体B的指针struct A&#123; struct B *partner; //other members;&#125;;//结构体B中包含指向结构体A的指针，在A声明完后，B也随之进行声明 struct B &#123; struct A *partner; //other members; &#125;; 访问结构成员为了访问结构的成员，我们使用成员访问运算符（.）。成员访问运算符是结构变量名称和我们要访问的结构成员之间的一个句号。您可以使用 struct 关键字来定义结构类型的变量。下面的实例演示了结构的用法： 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;string.h&gt; struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; int main( )&#123; struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy( Book1.title, "C Programming"); strcpy( Book1.author, "Nuha Ali"); strcpy( Book1.subject, "C Programming Tutorial"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy( Book2.title, "Telecom Billing"); strcpy( Book2.author, "Zara Ali"); strcpy( Book2.subject, "Telecom Billing Tutorial"); Book2.book_id = 6495700; /* 输出 Book1 信息 */ printf( "Book 1 title : %s\n", Book1.title); printf( "Book 1 author : %s\n", Book1.author); printf( "Book 1 subject : %s\n", Book1.subject); printf( "Book 1 book_id : %d\n", Book1.book_id); /* 输出 Book2 信息 */ printf( "Book 2 title : %s\n", Book2.title); printf( "Book 2 author : %s\n", Book2.author); printf( "Book 2 subject : %s\n", Book2.subject); printf( "Book 2 book_id : %d\n", Book2.book_id); return 0;&#125; 结果： 12345678Book 1 title : C ProgrammingBook 1 author : Nuha AliBook 1 subject : C Programming TutorialBook 1 book_id : 6495407Book 2 title : Telecom BillingBook 2 author : Zara AliBook 2 subject : Telecom Billing TutorialBook 2 book_id : 6495700 结构作为函数参数 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;string.h&gt; struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; /* 函数声明 */void printBook( struct Books book );int main( )&#123; struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy( Book1.title, "C Programming"); strcpy( Book1.author, "Nuha Ali"); strcpy( Book1.subject, "C Programming Tutorial"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy( Book2.title, "Telecom Billing"); strcpy( Book2.author, "Zara Ali"); strcpy( Book2.subject, "Telecom Billing Tutorial"); Book2.book_id = 6495700; /* 输出 Book1 信息 */ printBook( Book1 ); /* 输出 Book2 信息 */ printBook( Book2 ); return 0;&#125;void printBook( struct Books book )&#123; printf( "Book title : %s\n", book.title); printf( "Book author : %s\n", book.author); printf( "Book subject : %s\n", book.subject); printf( "Book book_id : %d\n", book.book_id);&#125; 结果： 12345678Book title : C ProgrammingBook author : Nuha AliBook subject : C Programming TutorialBook book_id : 6495407Book title : Telecom BillingBook author : Zara AliBook subject : Telecom Billing TutorialBook book_id : 6495700 指向结构的指针您可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示： 1struct Books *struct_pointer; 现在，您可以在上述定义的指针变量中存储结构变量的地址。为了查找结构变量的地址，请把 &amp; 运算符放在结构名称的前面，如下所示： 1struct_pointer = &amp;Book1; 为了使用指向该结构的指针访问结构的成员，您必须使用 -&gt; 运算符，如下所示： 1struct_pointer-&gt;title; 让我们使用结构指针来重写上面的实例，这将有助于您理解结构指针的概念： 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;stdio.h&gt;#include &lt;string.h&gt; struct Books&#123; char title[50]; char author[50]; char subject[100]; int book_id;&#125;; /* 函数声明 */void printBook( struct Books *book );int main( )&#123; struct Books Book1; /* 声明 Book1，类型为 Books */ struct Books Book2; /* 声明 Book2，类型为 Books */ /* Book1 详述 */ strcpy( Book1.title, "C Programming"); strcpy( Book1.author, "Nuha Ali"); strcpy( Book1.subject, "C Programming Tutorial"); Book1.book_id = 6495407; /* Book2 详述 */ strcpy( Book2.title, "Telecom Billing"); strcpy( Book2.author, "Zara Ali"); strcpy( Book2.subject, "Telecom Billing Tutorial"); Book2.book_id = 6495700; /* 通过传 Book1 的地址来输出 Book1 信息 */ printBook( &amp;Book1 ); /* 通过传 Book2 的地址来输出 Book2 信息 */ printBook( &amp;Book2 ); return 0;&#125;void printBook( struct Books *book )&#123; printf( "Book title : %s\n", book-&gt;title); printf( "Book author : %s\n", book-&gt;author); printf( "Book subject : %s\n", book-&gt;subject); printf( "Book book_id : %d\n", book-&gt;book_id);&#125; 当上面的代码被编译和执行时，它会产生下列结果： 12345678Book title : C ProgrammingBook author : Nuha AliBook subject : C Programming TutorialBook book_id : 6495407Book title : Telecom BillingBook author : Zara AliBook subject : Telecom Billing TutorialBook book_id : 6495700 字节对齐 内存空间按照字节划分，理论上可以从任何起始地址访问任意类型的变量。但实际中在访问特定类型变量时经常在特定的内存地址开始访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序一个接一个地存放，这就是对齐。 字节对齐的问题主要就是针对结构体。 123456789101112131415161718192021struct MyStruct1&#123; short a; int b; short c; &#125;;struct MyStruct2&#123; short a; short c; int b;&#125;;//自然对齐//1、某个变量存放的起始位置相对于结构的起始位置的偏移量是该变量字节数的整数倍；//2、结构所占用的总字节数是结构中字节数最长的变量的字节数的整数倍。// short = 2 补 2// int = 4// short = 2 补 2sizeof(MyStruct1) = 12// 2个short在一起组成一个 4 sizeof(MyStruct2) = 8 1234567891011#pragma pack(2) //指定以2字节对齐struct MyStruct1&#123; short a; int b; short c; &#125;;#pragma pack() //取消对齐//short = 2//int = 4//short = 2 合理的利用字节可以有效地节省存储空间 不合理的则会浪费空间、降低效率甚至还会引发错误。(对于部分系统从奇地址访问int、short等数据会导致错误)]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C 字符串]]></title>
    <url>%2Fc-string%2F</url>
    <content type="text"><![CDATA[前言在 C 语言中，字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 #正文 下面的声明和初始化创建了一个 “Hello” 字符串。由于在数组的末尾存储了空字符，所以字符数组的大小比单词 “Hello” 的字符数多一个。1char greeting[6] = &#123;'H', 'e', 'l', 'l', 'o', '\0'&#125;; 依据数组初始化规则，您可以把上面的语句写成以下语句： 1char greeting[] = "Hello"; 以下是 C/C++ 中定义的字符串的内存表示： 其实，您不需要把 null 字符放在字符串常量的末尾。C 编译器会在初始化数组时，自动把 ‘\0’ 放在字符串的末尾。让我们尝试输出上面的字符串： 12345678910#include &lt;stdio.h&gt;int main ()&#123; char str[6] = &#123;'H', 'e', 'l', 'l', 'o', '\0'&#125;; printf("str ===: %s\n", greeting ); return 0;&#125; 当上面的代码被编译和执行时，它会产生下列结果： 1str ===: Hello C 中有大量操作字符串的函数： 函数 作用 strcpy(s1, s2) 复制字符串 s2 到字符串 s1。 strcat(s1, s2) 连接字符串 s2 到字符串 s1 的末尾。 strlen(s1) 返回字符串 s1 的长度。 strcmp(s1, s2) 如果 s1 和 s2 是相同的，则返回 0；如果 s1s2 则返回大于 0。 strchr(s1, ch) 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 strstr(s1, s2) 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 实例 123456789101112131415161718192021222324#include &lt;stdio.h&gt;#include &lt;string.h&gt; int main ()&#123; char str1[12] = "Hello"; char str2[12] = "World"; char str3[12]; int len ; /* 复制 str1 到 str3 */ strcpy(str3, str1); printf("strcpy( str3, str1) : %s\n", str3 ); /* 连接 str1 和 str2 */ strcat( str1, str2); printf("strcat( str1, str2): %s\n", str1 ); /* 连接后，str1 的总长度 */ len = strlen(str1); printf("strlen(str1) : %d\n", len ); return 0;&#125; 结果123strcpy( str3, str1) : Hellostrcat( str1, str2): HelloWorldstrlen(str1) : 10]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[android：jni NDK到底是什么？（含实例教学）]]></title>
    <url>%2FjniNDK%2F</url>
    <content type="text"><![CDATA[前言 在Android开发中，使用 NDK开发的需求正逐渐增大 但很多人却搞不懂 JNI 与 NDK 到底是怎么回事 今天，我将先介绍JNI 与 NDK &amp; 之间的区别，手把手进行 NDK的使用教学，希望你们会喜欢 目录 JNI介绍简介 定义：Java Native Interface，即 Java本地接口 作用： 使得Java 与 本地其他类型语言（如C、C++）交互 1即在 Java代码 里调用 C、C++等语言的代码 或 C、C++代码调用 Java 代码 特别注意： 1.JNI是 Java 调用 Native 语言的一种特性2.JNI 是属于 Java 的，与 Android 无直接关系 为什么要有 JNI 背景：实际使用中，Java 需要与 本地代码 进行交互 问题：因为 Java 具备跨平台的特点，所以Java 与 本地代码交互的能力非常弱 解决方案： 采用 JNI特性 增强 Java 与 本地代码交互的能力实现步骤 在Java中声明Native方法（即需要调用的本地方法） 编译上述 Java源文件javac（得到 .class文件） 通过 javah 命令导出JNI的头文件（.h文件） 使用 Java需要交互的本地代码 实现在 Java中声明的Native方法 1如 Java 需要与 C++ 交互，那么就用C++实现 Java的Native方法 编译.so库文件 通过Java命令执行 Java程序，最终实现Java调用本地代码NDK介绍简介 定义：Native Development Kit，是 Android的一个工具开发包 1NDK是属于 Android 的，与Java并无直接关系 作用：快速开发C、 C++的动态库，并自动将so和应用一起打包成 APK即可通过 NDK在 Android中 使用 JNI与本地代码（如C、C++）交互 应用场景：在Android的场景下 使用JNI 1即 Android开发的功能需要本地代码（C/C++）实现 特点 额外注意使用步骤 配置 Android NDK环境 创建 Android 项目，并与 NDK进行关联 在 Android 项目中声明所需要调用的 Native方法 使用 Android需要交互的本地代码 实现在Android中声明的Native方法 1比如 Android 需要与 C++ 交互，那么就用C++ 实现 Java的Native方法 通过 ndk - bulid 命令编译产生.so库文件 编译 Android Studio 工程，从而实现 Android 调用本地代码NDK与JNI关系具体使用本文根据版本的不同介绍了两种在Android Studio中实现 NDK的方法：Android Studio2.2 以下 &amp; 2.2以上Android Studio2.2 以下实现NDK 步骤如下 配置 Android NDK环境 关联 Andorid Studio项目 与 NDK 创建本地代码文件（即需要在 Android项目中调用的本地代码文件） 创建 Android.mk文件 &amp; Application.mk文件 编译上述文件，生成.so库文件，并放入到工程文件中 在 Andoird Studio项目中使用 NDK实现 JNI 功能 步骤详解步骤1：配置 Android NDK环境具体请看文章手把手教你配置Android NDK环境步骤2： 关联Andorid Studio项目 与 NDK 当你的项目每次需要使用 NDK 时，都需要将该项目关联到 NDK 121.此处使用的是Andorid Studio，与Eclipse不同2.还在使用Eclipse的同学请自行查找资料配置 具体配置如下a. 在Gradle的 local.properties中添加配置 1ndk.dir=/Users/Carson_Ho/Library/Android/sdk/ndk-bundle 1若ndk目录存放在SDK的目录中，并命名为ndk-bundle，则该配置自动添加 b. 在Gradle的 gradle.properties中添加配置12android.useDeprecatedNdk=true // 对旧版本的NDK支持 c. 在Gradle的build.gradle添加ndk节点 至此，将Andorid Studio的项目 与 NDK 关联完毕 下面，将真正开始讲解如何在项目中使用NDK 步骤3：创建本地代码文件 即需要在Android项目中调用的本地代码文件此处采用 C++作为展示test.cpp 1234567891011121314# include &lt;jni.h&gt;# include &lt;stdio.h&gt;extern "C"&#123; JNIEXPORT jstring JNICALL Java_scut_carson_1ho_ndk_1demo_MainActivity_getFromJNI(JNIEnv *env, jobject obj )&#123; // 参数说明 // 1. JNIEnv：代表了VM里面的环境，本地的代码可以通过该参数与Java代码进行操作 // 2. obj：定义JNI方法的类的一个本地引用（this） return env -&gt; NewStringUTF("Hello i am from JNI!"); // 上述代码是返回一个String类型的"Hello i am from JNI!"字符串 &#125;&#125; 此处需要注意： 如果本地代码是C++（.cpp或者.cc），要使用extern “C” { }把本地方法括进去 JNIEXPORT jstring JNICALL中的JNIEXPORT 和 JNICALL不能省 关于方法名Java_scut_carson_1ho_ndk_1demo_MainActivity_getFromJNI 格式 = Java _包名 _ 类名_Java需要调用的方法名 Java必须大写 对于包名，包名里的.要改成_，_要改成_1 123如我的包名是：scut.carson_ho.ndk_demo，则需要改成scut_carson_1ho_ndk_1demo 最后，将创建好的test.cpp文件放入到工程文件目录中的src/main/jni文件夹 若无jni文件夹，则手动创建。 下面我讲解一下JNI类型与Java类型对应的关系介绍 步骤4：创建Android.mk文件 作用：指定源码编译的配置信息 1如工作目录，编译模块的名称，参与编译的文件等 具体使用Android.mk 123456789101112131415LOCAL_PATH := $(call my-dir)// 设置工作目录，而my-dir则会返回Android.mk文件所在的目录include $(CLEAR_VARS)// 清除几乎所有以LOCAL——PATH开头的变量（不包括LOCAL_PATH）LOCAL_MODULE := hello_jni// 设置模块的名称，即编译出来.so文件名// 注，要和上述步骤中build.gradle中NDK节点设置的名字相同LOCAL_SRC_FILES := test.cpp// 指定参与模块编译的C/C++源文件名include $(BUILD_SHARED_LIBRARY)// 指定生成的静态库或者共享库在运行时依赖的共享库模块列表。 最后，将上述文件同样放在src/main/jni文件夹中。 步骤5：创建Application.mk文件 作用：配置编译平台相关内容 具体使用 Application.mk12345APP_ABI := armeabi// 最常用的APP_ABI字段：指定需要基于哪些CPU平台的.so文件// 常见的平台有armeabi x86 mips，其中移动设备主要是armeabi平台// 默认情况下，Android平台会生成所有平台的.so文件，即同APP_ABI := armeabi x86 mips// 指定CPU平台类型后，就只会生成该平台的.so文件，即上述语句只会生成armeabi平台的.so文件 最后，将上述文件同样放在src/main/jni文件夹中 步骤6：编译上述文件，生成.so库文件 经过上述步骤，在src/main/jni文件夹中已经有3个文件打开终端，输入以下命令 1234// 步骤1：进入该文件夹cd /Users/Carson_Ho/AndroidStudioProjects/NDK_Demo/app/src/main/jni // 步骤2：运行NDK编译命令ndk-build 编译成功后，在src/main/会多了两个文件夹libs &amp; obj，其中libs下存放的是.so库文件步骤7：在src/main/中创建一个名为jniLibs的文件夹，并将上述生成的so文件夹放到该目录下1.要把名为 CPU平台的文件夹放进去，而不是把.so文件放进去2.如果本来就有.so文件，那么就直接创建名为jniLibs的文件夹并放进去就可以步骤8：在Andoird Studio项目中使用NDK实现JNI功能 此时，我们已经将本地代码文件编译成.so库文件并放入到工程文件中 在Java代码中调用本地代码中的方法，具体代码如下： MainActivity.java 123456789101112131415161718192021222324252627282930public class MainActivity extends AppCompatActivity &#123; // 步骤1:加载生成的so库文件 // 注意要跟.so库文件名相同 static &#123; System.loadLibrary("hello_jni"); &#125; // 步骤2:定义在JNI中实现的方法 public native String getFromJNI(); // 此处设置了一个按钮用于触发JNI方法 private Button Button; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 通过Button调用JNI中的方法 Button = (Button) findViewById(R.id.button); Button.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; Button.setText(getFromJNI()); &#125; &#125;); &#125; 主布局文件：_activity_main.xml_ 12345678910111213141516171819&lt;RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:tools="http://schemas.android.com/tools" android:layout_width="match_parent" android:layout_height="match_parent" android:paddingBottom="@dimen/activity_vertical_margin" android:paddingLeft="@dimen/activity_horizontal_margin" android:paddingRight="@dimen/activity_horizontal_margin" android:paddingTop="@dimen/activity_vertical_margin" tools:context="scut.carson_ho.ndk_demo.MainActivity"&gt; // 此处设置了一个按钮用于触发JNI方法 &lt;Button android:id="@+id/button" android:layout_centerInParent="true" android:layout_width="300dp" android:layout_height="50dp" android:text="调用JNI代码" /&gt;&lt;/RelativeLayout&gt; 结果展示]]></content>
      <categories>
        <category>android</category>
        <category>JNI</category>
        <category>NDK</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>JNI</tag>
        <tag>NDK</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RecyclerView 进阶]]></title>
    <url>%2FRecyclerView%2F</url>
    <content type="text"><![CDATA[前言现在RecyclerView的应用越来越广泛了，不同的应用场景需要其作出不同的改变。有时候我们可能需要实现侧滑删除的功能，比如知乎首页的侧滑删除，又或者长按Item进行拖动与其他Item进行位置的交换，但RecyclerView没有提供现成的API供我们操作，所幸SDK提供了ItemTouchHelper这样一个工具类帮助我们快速实现以上功能。不多说别的，我们来介绍一下ItemTouchHelper。 什么是ItemTouchHelper12345This is a utility class to add swipe to dismiss and drag &amp; drop support to RecyclerView.It works with a RecyclerView and a Callback class, which configures what type of interactions are enabled and also receives events when user performs these actions.Depending on which functionality you support, you should override onMove(RecyclerView, ViewHolder, ViewHolder) and / or onSwiped(ViewHolder, int). 以上是官方文档的介绍，ItemTouchHelper是一个工具类，可实现侧滑删除和拖拽移动，使用这个工具类需要RecyclerView和Callback。同时根据需要重写onMove和onSwiped方法。接下来就来讲述ItemTouchHelper的使用方法。 ItemTouchHelper基本使用方法step.1新建一个接口，让Adapter实现之从解耦的角度考虑，我们需要一个接口来实现Adapter和ItemTouchHelper之间涉及数据的操作，因为ItemTouchHelper在完成触摸的各种动画后，就要对Adapter的数据进行操作，比如侧滑删除操作，最后需要调用Adapter的notifyItemRemove()方法来移除该数据。因此我们可以把数据操作的部分抽象成一个接口方法，让ItemTouchHelper.Callback调用该方法即可。具体如下：新建ItemTouchHelperAdapter:123456public interface ItemTouchHelperAdapter &#123; //数据交换 void onItemMove(int fromPosition,int toPosition); //数据删除 void onItemDissmiss(int position);&#125; 让我们的Adapter实现该接口：12345678910111213141516171819public class MyAdapter extends RecyclerView.Adapter&lt;RecyclerView.ViewHolder&gt; implements ItemTouchHelperAdapter &#123; //数据 private List&lt;String&gt; mData; ... @Override public void onItemMove(int fromPosition, int toPosition) &#123; //交换位置 Collections.swap(mData,fromPosition,toPosition); notifyItemMoved(fromPosition,toPosition); &#125; @Override public void onItemDissmiss(int position) &#123; //移除数据 mData.remove(position); notifyItemRemoved(position); &#125;&#125; 那么我们在ItemTouchHelper.Callback内直接调用接口的方法即可。 step.2新建类继承自ItemTouchHelper.Callback从官方文档我们知道，使用ItemTouchHelper需要一个Callback，该Callback是ItemTouchHelper.Callback的子类，所以我们需要新建一个类比如SimpleItemTouchHelperCallback继承自ItemTouchHelper.Callback。我们可以重写其数个方法来实现我们的需求。我们先来看看ItemTouchHelper.Callback需要重写的几个常用的方法。 1、public int getMovementFlags(RecyclerView, RecyclerView.ViewHolder)： 该方法用于返回可以滑动的方向，比如说允许从右到左侧滑，允许上下拖动等。我们一般使用makeMovementFlags(int,int)或makeFlag(int, int)来构造我们的返回值。 例如：要使RecyclerView的Item可以上下拖动，同时允许从右到左侧滑，但不许允许从左到右的侧滑，我们可以这样写：123456@Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) &#123; int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; //允许上下的拖动 int swipeFlags = ItemTouchHelper.LEFT; //只允许从右向左侧滑 return makeMovementFlags(dragFlags,swipeFlags); &#125; 2、public boolean onMove (RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)当用户拖动一个Item进行上下移动从旧的位置到新的位置的时候会调用该方法，在该方法内，我们可以调用Adapter的notifyItemMoved方法来交换两个ViewHolder的位置，最后返回true，表示被拖动的ViewHolder已经移动到了目的位置。所以，如果要实现拖动交换位置，可以重写该方法（前提是支持上下拖动）： @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) { //onItemMove是接口方法 mAdapter.onItemMove(viewHolder.getAdapterPosition(),target.getAdapterPosition()); return true; } 3、public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction)当用户左右滑动Item达到删除条件时，会调用该方法，一般手指触摸滑动的距离达到RecyclerView宽度的一半时，再松开手指，此时该Item会继续向原先滑动方向滑过去并且调用onSwiped方法进行删除，否则会反向滑回原来的位置。在该方法内部我们可以这样写： @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) { //onItemDissmiss是接口方法 mAdapter.onItemDissmiss(viewHolder.getAdapterPosition()); } 如果在onSwiped方法内我们没有进行任何操作，即不删除已经滑过去的Item，那么就会留下空白的地方，因为实际上该ItemView还占据着该位置，只是移出了我们的可视范围内罢了。 4、public boolean isLongPressDragEnabled()：该方法返回true时，表示支持长按拖动，即长按ItemView后才可以拖动，我们遇到的场景一般也是这样的。默认是返回true。 5、public boolean boolean isItemViewSwipeEnabled()：该方法返回true时，表示如果用户触摸并左右滑动了View，那么可以执行滑动删除操作，即可以调用到onSwiped()方法。默认是返回true。 6、public void onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState)：从静止状态变为拖拽或者滑动的时候会回调该方法，参数actionState表示当前的状态。 7、public void clearView(RecyclerView recyclerView, ViewHolder viewHolder)：当用户操作完毕某个item并且其动画也结束后会调用该方法，一般我们在该方法内恢复ItemView的初始状态，防止由于复用而产生的显示错乱问题。 8、public void onChildDraw(…)：我们可以在这个方法内实现我们自定义的交互规则或者自定义的动画效果。那么完整的SimpleItemTouchHelperCallback文件是这样的： public class SimpleItemTouchHelperCallback extends ItemTouchHelper.Callback{ private ItemTouchHelperAdapter mAdapter; public SimpleItemTouchHelperCallback(ItemTouchHelperAdapter adapter){ mAdapter = adapter; } @Override public int getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) { int dragFlags = ItemTouchHelper.UP | ItemTouchHelper.DOWN; int swipeFlags = ItemTouchHelper.LEFT; return makeMovementFlags(dragFlags,swipeFlags); } @Override public boolean isLongPressDragEnabled() { return true; } @Override public boolean isItemViewSwipeEnabled() { return true; } @Override public boolean onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target) { mAdapter.onItemMove(viewHolder.getAdapterPosition(),target.getAdapterPosition()); return true; } @Override public void onSwiped(RecyclerView.ViewHolder viewHolder, int direction) { mAdapter.onItemDissmiss(viewHolder.getAdapterPosition()); } } step.3为RecycleView添加ItemTouchHelper上面我们修改了Adapter和新建了ItemTouchHelper.Callback的子类，接下来我们要为RecyclerView添加ItemTouchHelper： //先实例化Callback ItemTouchHelper.Callback callback = new SimpleItemTouchHelperCallback(myAdapter); //用Callback构造ItemtouchHelper ItemTouchHelper touchHelper = new ItemTouchHelper(callback); //调用ItemTouchHelper的attachToRecyclerView方法建立联系 touchHelper.attachToRecyclerView(mRecyclerView); 经过以上步骤，我们已经实现了Item的拖拽和侧滑删除功能了，看一下效果： 自定义侧滑动画有时候我们对默认的动画效果可能不满意，需要自己实现想要的动画效果，ItemTouchHelper.Callback提供的onChildDraw方法可以让我们很方便地实现想要的效果。以下带来一种自定义的实现效果，当做抛砖引玉，让大家熟悉自定义效果的运用。先来看看要实现的效果： 该效果是比较常见的，用户向左滑动Item的时候，一开始提示的是“左滑删除”，滑动到一定距离后，显示删除的图标，并且随着滑动距离的增加该图标不断变大，达到最大后用户松开手指，该Item被删除。接下来我们来分析一下怎样实现以上的效果：首先，要想左滑出现一个删除的方块，可以在LinearLayout放一个这样的“方块”，让它与Item水平并排排列，以下是布局文件： &lt;?xml version="1.0" encoding="utf-8"?&gt; &lt;LinearLayout xmlns:android="http://schemas.android.com/apk/res/android" xmlns:app="http://schemas.android.com/apk/res-auto" android:layout_height="wrap_content" android:layout_width="match_parent" android:orientation="horizontal"&gt; &lt;android.support.v7.widget.CardView android:layout_width="match_parent" android:layout_height="80dp" android:background="#ffffff" android:layout_marginLeft="4dp" android:layout_marginRight="4dp" android:layout_marginBottom="4dp" app:cardCornerRadius="1dp" app:elevation="1dp" app:contentPadding="1dp"&gt; &lt;RelativeLayout android:layout_width="match_parent" android:layout_height="match_parent" android:background="#ffffff"&gt; &lt;TextView android:id="@+id/item" android:layout_width="wrap_content" android:layout_height="wrap_content" android:textSize="22sp" android:padding="4dp" android:layout_centerInParent="true"/&gt; &lt;/RelativeLayout&gt; &lt;/android.support.v7.widget.CardView&gt; &lt;FrameLayout android:layout_width="100dp" android:layout_height="match_parent" android:layout_marginRight="4dp" android:layout_marginBottom="4dp" android:background="#f33213"&gt; &lt;ImageView android:id="@+id/iv_img" android:layout_width="50dp" android:layout_height="50dp" android:layout_gravity="center" android:src="@mipmap/ic_eye_72" android:visibility="invisible"/&gt; &lt;TextView android:id="@+id/tv_text" android:layout_width="wrap_content" android:layout_height="wrap_content" android:text="左滑删除" android:textSize="18sp" android:textColor="#ffffff" android:layout_gravity="center"/&gt; &lt;/FrameLayout&gt; &lt;/LinearLayout&gt; 布局文件修改后，我们尝试来滑动一下，发现后面的删除方块并不会出现，这是因为默认的滑动方式是setTranslationX(int)，即是对整个View的滑动，所以无论我们怎样滑动，都不会出现删除方块。因此，我们要改变一个种滑动方式，比如使用scrollTo(int,int),这种是对View的内容的滑动，所以随着左滑，item会向左滑去，而位于右方的方块自然也就出现了。 接着，我们考虑该“删除眼睛”的图标是怎样从小变大的，这个实现也比较简单，只要根据滑动的距离对该ImageView的LayoutParams.width进行改变就行了，不过要注意限制大小，否则过大会造成图片的失真。当滑动距离等于RecyclerView宽度的一半时，此时松开手会使Item删除，那么我们可以在该滑动距离达到该值时时“眼睛”变得最大，此时可以达到良好的交互效果，提示了用户无需继续滑动即可删除该Item了。 最后我们要考虑的是：在删除了Item或者没删除而滑回原来的位置后，我们要把所做的改变重置一下，否则，会由于RecyclerView的复用而导致其他位置的ViewHolder与当前的ViewHolder所做的改变一样，即造成显示的错误。我们可以在clearView()方法内重置改变，这样就能解决因复用而导致的显示问题了。 最后我们来看看SimpleItemTouchHelperCallback的代码： public class SimpleItemTouchHelperCallback extends ItemTouchHelper.Callback{ //省略上面的代码.... //限制ImageView长度所能增加的最大值 private double ICON_MAX_SIZE = 50; //ImageView的初始长宽 private int fixedWidth = 150; @Override public void clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder) { super.clearView(recyclerView, viewHolder); //重置改变，防止由于复用而导致的显示问题 viewHolder.itemView.setScrollX(0); ((MyAdapter.NormalItem)viewHolder).tv.setText("左滑删除"); FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) ((MyAdapter.NormalItem) viewHolder).iv.getLayoutParams(); params.width = 150; params.height = 150; ((MyAdapter.NormalItem) viewHolder).iv.setLayoutParams(params); ((MyAdapter.NormalItem) viewHolder).iv.setVisibility(View.INVISIBLE); } @Override public void onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, float dX, float dY, int actionState, boolean isCurrentlyActive) { //仅对侧滑状态下的效果做出改变 if (actionState ==ItemTouchHelper.ACTION_STATE_SWIPE){ //如果dX小于等于删除方块的宽度，那么我们把该方块滑出来 if (Math.abs(dX) &lt;= getSlideLimitation(viewHolder)){ viewHolder.itemView.scrollTo(-(int) dX,0); } //如果dX还未达到能删除的距离，此时慢慢增加“眼睛”的大小，增加的最大值为ICON_MAX_SIZE else if (Math.abs(dX) &lt;= recyclerView.getWidth() / 2){ double distance = (recyclerView.getWidth() / 2 -getSlideLimitation(viewHolder)); double factor = ICON_MAX_SIZE / distance; double diff = (Math.abs(dX) - getSlideLimitation(viewHolder)) * factor; if (diff &gt;= ICON_MAX_SIZE) diff = ICON_MAX_SIZE; ((MyAdapter.NormalItem)viewHolder).tv.setText(""); //把文字去掉 ((MyAdapter.NormalItem) viewHolder).iv.setVisibility(View.VISIBLE); //显示眼睛 FrameLayout.LayoutParams params = (FrameLayout.LayoutParams) ((MyAdapter.NormalItem) viewHolder).iv.getLayoutParams(); params.width = (int) (fixWidth + diff); params.height = (int) (fixWidth + diff); ((MyAdapter.NormalItem) viewHolder).iv.setLayoutParams(params); } }else { //拖拽状态下不做改变，需要调用父类的方法 super.onChildDraw(c,recyclerView,viewHolder,dX,dY,actionState,isCurrentlyActive); } } /** * 获取删除方块的宽度 */ public int getSlideLimitation(RecyclerView.ViewHolder viewHolder){ ViewGroup viewGroup = (ViewGroup) viewHolder.itemView; return viewGroup.getChildAt(1).getLayoutParams().width; } } 原文链接：http://tianrongchuang.top/]]></content>
      <categories>
        <category>android</category>
        <category>ui</category>
        <category>RecyclerView</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>ui</tag>
        <tag>RecyclerView</tag>
      </tags>
  </entry>
</search>
